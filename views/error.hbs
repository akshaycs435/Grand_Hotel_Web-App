var express = require("express");
var router = express.Router();


const {
 
  loginPage,
  signuppage,
  signup,
  homepage,
  allrooms,
  room,
  login,
  booking,
  bookingrooms,
  paymentpage,
  payment,
  checkavailabilty


} = require("../controllers/userController");


router.get("/",homepage);

router.get("/signup",signuppage);

router.post("/signup",signup);

router.get("/login", loginPage);

router.post("/login", login);

router.get("/allrooms/:id",allrooms);

router.get("/room/:id",room);

router.get("/booking/:id",booking);

router.post("/bookingroom/:id", bookingrooms);

router.get("/payment/:id", paymentpage);

router.post("/dopayment",payment);

router.post("/checkavailability/:id",checkavailabilty);


module.exports = router;


======================================================================



const { CURSOR_FLAGS } = require("mongodb");
const userHelper = require("../helpers/userHelper");
const { render } = require("../app");
const multer = require("multer");
const Razorpay = require("razorpay");
var { connectToMongoDB } = require("../config/connection");
const { ObjectId } = require("mongodb");
var collection = require("../config/collection");


// const { RAZORPAY_ID_KEY, RAZORPAY_SECRET_KEY } = process.env;
const razorpayInstance = new Razorpay({
  key_id: "rzp_test_8cTRaG2qyqmSGG",
  key_secret: "lPhtD4Guxq3dUurYJLs9OwXi"
});



module.exports = {

  signuppage:(req,res) => {

    res.render("user/signupPage");
  },

  signup:(req,res) => {
    // console.log("##################3",req.body);

    try {
      userHelper.doSignup(req.body).then((response) => {
        // console.log(response);
        res.redirect("/login");
      });
    } catch (error) {
      console.log(error);
    }

  },

  loginPage: (req, res, next) => {
    res.render("user/login");
  },

login: (req, res, next) => {
  try {
    userHelper.doLogin(req.body).then((response) => {
      console.log("#############33",response);
      if (response.status) {
        res.redirect("/allRooms"); 
      } else {
        res.render("user/login", { error: response.message });
      }
    });
  } catch (error) {
    console.log(error);
  }
},


  homepage:(req,res) => {
    userHelper.showhotels().then((hotelssdata) => {
      res.render("user/homePage",{
        hotelssdata,
      });
    })
  },


  allrooms: (req, res) => {
    let hotelId = req.params.id; // Fetch the hotelId from route parameters
    try {
        userHelper.showrooms(hotelId).then((roomsdata) => {
            console.log("$$$$$$$$$$$$$$", roomsdata);
            res.render("user/allRooms", {
                roomsdata
            });
        });
    } catch (error) {
        console.error(error);
        res.status(500).send("Error fetching rooms data");
    }
},


  room: (req, res) => {
    let id = req.params.id;
    try {
         userHelper.roomsDetails(id).then((roomDetails)=>{
          console.log("roooomsssdetailsss",roomDetails);
          res.render("user/room", { roomDetails });
         });
    } catch (error) {
        console.error(error);
        res.status(500).send("Error fetching room details");
    }
  },



  booking:(req,res) =>{
    let id = req.params.id;
    try {
         userHelper.roomsDetails(id).then((roomDetails)=>{
          res.render("user/booking", { roomDetails });
         });
    } catch (error) {
        console.error(error);
        res.status(500).send("Error fetching room details");
    }
  },
  


  bookingrooms: (req, res) => {
    let roomId = req.params.id; // Correctly retrieve room ID from request parameters

    try {
        userHelper.dobooking(req.body).then((result) => {
            console.log(result);
            // Render the payment page with the correct room ID
            res.redirect("/payment/" + roomId);
        });
    } catch (error) {
        console.log(error);
    }
},




  checkavailabilty: async (req, res) => {

    const roomId = req.params.id;

    console.log("rooooooooooooomidddddddddddd",roomId);

    const { checkin, checkout } = req.body;

    try {
        const bookingData = await userHelper.dochecking(checkin, checkout,roomId);


        if (!bookingData) {
            // Dates are available and not booked, proceed with booking
            console.log("Dates are available for booking");
            try {
                // Redirect to booking page after successful booking
                res.redirect("/booking/" + roomId);
            } catch (error) {
                console.log("Error in redirecting to booking page:", error);
                res.redirect("/"); // Redirect to home page with an error message
            }
        } else {
            // Dates are not available or already booked, inform the user
            console.log("Selected dates are not available or already booked");
            res.redirect("/room/" + roomId); // Redirect to room page or any other appropriate route
        }
    } catch (error) {
        console.log("Error checking availability:", error);
        res.redirect("/"); // Redirect to home page with an error message
    }
},


paymentpage:(req,res)=>{
  let id = req.params.id;
  try {
       userHelper.roomsDetails(id).then((roomDetails)=>{
        console.log("rooooomdetailsssss&&&&&&&&&&&&&",roomDetails);
        res.render("user/payment", { roomDetails });
       });
  } catch (error) {
      console.error(error);
      res.status(500).send("Error fetching room details");
  }

},
 

payment: async (req, res) => {
  try {
      const { name, price } = req.body;

      const paymentResult = await userHelper.payment(name, price);

      // Send response back to client
      res.status(200).send(paymentResult);
  } catch (error) {
      console.log(error.message);
      // Handle error
      res.status(500).send({ success: false, msg: 'Something went wrong!' });
  }
}




}



===============================================================================================



var { connectToMongoDB } = require("../config/connection");
var collection = require("../config/collection");
const bcrypt = require("bcrypt");
const { ObjectId } = require("mongodb");
const jwt = require("jsonwebtoken");
const Razorpay = require("razorpay");


const razorpayInstance = new Razorpay({
  key_id: "rzp_test_8cTRaG2qyqmSGG",
  key_secret: "lPhtD4Guxq3dUurYJLs9OwXi"
});


module.exports = {


  doSignup: (userData) => {
    return new Promise(async (resolve, reject) => {
      //   console.log(userData);

      if (userData.password === userData.confirmpassword) {
        var encryptedpassword = await bcrypt.hash(userData.password, 10);
        // console.log(encryptedpassword);
      } else {
        console.log("error");
        throw new Error("given passwords are not same");
      }

      let signupData = {


        userId:Date.now().toString(16),


        name: userData.name,
        email: userData.email,
        password: encryptedpassword,
        blocked: false,
      };

      const db = await connectToMongoDB();

      await db
        .collection(collection.USER_COLLECTION)
        .insertOne(signupData)
        .then((data) => {
          resolve(data.insertedId);
        });
    });
  },


  doLogin: (loginData) => {
    return new Promise(async (resolve, reject) => {
      let loginstatus = false;
      let response = {};
      const db = await connectToMongoDB();
      let user = await db
        .collection(collection.USER_COLLECTION)
        .findOne({ email: loginData.email });

      if (user) {
        bcrypt.compare(loginData.password, user.password).then((status) => {
          if (status) {
            console.log("login success");
            const usertoken = jwt.sign(
              { userId: user._id, useremail: user.email },
              "secret",
              { expiresIn: "24h" }
            );
            response.token = usertoken;
            response.user = user;
            response.status = true;
            response.message = "Login Success";
            resolve(response);
          } else {
            response.message = "the user cant login";
            resolve({ status: false });
          }
        });
      } else {
        resolve({ status: false });
      }
    });
  },


  showhotels: async () => {
    return new Promise(async (resolve, reject) => {
      const db = await connectToMongoDB();

      let Datahotel = await db
        .collection(collection.HOTEL_COLLECTION)
        .find({ blocked: false })
        .toArray();
      resolve(Datahotel);
    });
  },


  showrooms: async (hotelId) => {
    try {
        const db = await connectToMongoDB();
        const hotelrooms = await db
            .collection(collection.ROOMS_COLLECTION)
            .find({ hotelId: hotelId })
            .toArray();
        return hotelrooms;
    } catch (error) {
        console.error("Error fetching hotel rooms:", error);
        throw error; // Propagate the error to the caller
    }
},


  roomsDetails: async (roomid) => {
    try {
      const db = await connectToMongoDB();
      const roomDetails = await db
        .collection(collection.ROOMS_COLLECTION)
        .findOne({ _id: new ObjectId(roomid) });
      return roomDetails;
    } catch (error) {
      throw error;
    }
  },


  dobooking: (bookingdata) => {
    // Function to generate array of dates between checkin and checkout
    function generateDateArray(checkin, checkout) {
        let datesArray = [];
        let currentDate = new Date(checkin);
        const endDate = new Date(checkout);
        
        // Loop through each day between checkin and checkout
        while (currentDate <= endDate) {
            datesArray.push(new Date(currentDate));
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return datesArray;
    }

    return new Promise(async (resolve, reject) => {
        let datasbooking = {
            roomId:roomId,
            name: bookingdata.name,
            email: bookingdata.email,
            checkin: bookingdata.checkin,
            checkout: bookingdata.checkout,
            booked: false,
        };

        const db = await connectToMongoDB();

        // Generate array of dates between checkin and checkout
        let datesArray = generateDateArray(bookingdata.checkin, bookingdata.checkout);

        // Add the array of dates to datasbooking object
        datasbooking.datesArray = datesArray;

        await db
            .collection(collection.BOOKING_COLLECTION)
            .insertOne(datasbooking)
            .then((data) => {
                resolve(data.insertedId);
            })
            .catch((error) => {
                reject(error);
            });
    });
},







dochecking: async (checkin, checkout,roomId) => {

  console.log("3#######%%%%%%%%%",checkin,checkout);
  
  try {
      const db = await connectToMongoDB();
      
      // Query the booking collection to check if any booking exists for the given date range
      const existingBooking = await db.collection(collection.BOOKING_COLLECTION).findOne({
          // $or: [
          //     { $and: [{ checkin: { $lte: new Date(checkin) } }, { checkout: { $gte: new Date(checkin) } }] }, // Check-in date falls within existing booking
          //     { $and: [{ checkin: { $lte: new Date(checkout) } }, { checkout: { $gte: new Date(checkout) } }] }, // Check-out date falls within existing booking
          //     { $and: [{ checkin: { $gte: new Date(checkin) } }, { checkout: { $lte: new Date(checkout) } }] } // Existing booking falls within the given date range
          // ]
          checkin,checkout,roomId
      });

      // Return the booking data if exists, otherwise return null
      return existingBooking;
  } catch (error) {
      throw error;
  }
},



payment: async (name, price) => {
  
  try {
      // Create options object for Razorpay order
      const options = {
          amount: price * 100, // Amount should be in smallest currency unit (paisa for INR)
          currency: 'INR',
          receipt: 'razorUser@gmail.com',
          payment_capture: '1' // Automatically capture payments
      };

      // Create Razorpay order
      const order = await new Promise((resolve, reject) => {
          razorpayInstance.orders.create(options, (err, order) => {
              if (err) {
                  reject(err);
              } else {
                  resolve(order);
              }
          });
      });

      // If order creation is successful, save payment details to MongoDB
      const paymentDetails = {
          name: name,
          amount: price,
          order_id: order.id,
          status: 'success' // Initial status
      };

      // Connect to MongoDB
      const db = await connectToMongoDB();

      // Insert payment details into MongoDB payment collection
      await db.collection(collection.PAYMENT_COLLECTION).insertOne(paymentDetails);

      // Return order details
      return {
          success: true,
          msg: 'Order Created',
          order_id: order.id,
          amount: options.amount,
          key_id: "rzp_test_8cTRaG2qyqmSGG",
          product_name: name
      };
  } catch (error) {
      console.log(error.message);
      throw error;
  }
}



};


--------------------------------------------------

const { CURSOR_FLAGS } = require("mongodb");
const userHelper = require("../helpers/userHelper");
const { render } = require("../app");
const multer = require("multer");
const Razorpay = require("razorpay");
var { connectToMongoDB } = require("../config/connection");
const { ObjectId } = require("mongodb");
var collection = require("../config/collection");


// const { RAZORPAY_ID_KEY, RAZORPAY_SECRET_KEY } = process.env;
const razorpayInstance = new Razorpay({
  key_id: "rzp_test_8cTRaG2qyqmSGG",
  key_secret: "lPhtD4Guxq3dUurYJLs9OwXi"
});



module.exports = {

  signuppage:(req,res) => {

    res.render("user/signupPage");
  },

  signup:(req,res) => {
    // console.log("##################3",req.body);

    try {
      userHelper.doSignup(req.body).then((response) => {
        // console.log(response);
        res.redirect("/login");
      });
    } catch (error) {
      console.log(error);
    }

  },

  loginPage: (req, res, next) => {
    res.render("user/login");
  },

login: (req, res, next) => {
  try {
    userHelper.doLogin(req.body).then((response) => {
      console.log("#############33",response);
      if (response.status) {
        res.redirect("/allRooms"); 
      } else {
        res.render("user/login", { error: response.message });
      }
    });
  } catch (error) {
    console.log(error);
  }
},


  homepage:(req,res) => {
    userHelper.showhotels().then((hotelssdata) => {
      res.render("user/homePage",{
        hotelssdata,
      });
    })
  },


  allrooms: (req, res) => {
    let hotelId = req.params.id; // Fetch the hotelId from route parameters
    try {
        userHelper.showrooms(hotelId).then((roomsdata) => {
            console.log("$$$$$$$$$$$$$$", roomsdata);
            res.render("user/allRooms", {
                roomsdata
            });
        });
    } catch (error) {
        console.error(error);
        res.status(500).send("Error fetching rooms data");
    }
},


room: (req, res) => {

  let id = req.params.id;

  try {
       userHelper.roomsDetails(id).then((roomdata)=>{

        console.log("roooooomdetailssss",roomdata);
        res.render("user/room", { roomdata }); // Pass roomDetails object to the template
       });
  } catch (error) {
      console.error(error);
      res.status(500).send("Error fetching room details");
  }
},



  // booking:(req,res) =>{
  //   let id = req.params.id;
    
  //   try {
  //        userHelper.roomsDetails(id).then((roomDetails)=>{
  //         res.render("user/booking", { roomDetails });
  //        });
  //   } catch (error) {
  //       console.error(error);
  //       res.status(500).send("Error fetching room details");
  //   }
  // },

  booking:(req,res) => {

    res.render("user/booking");

  },
  


  bookingrooms: (req, res) => {

    let roomId = req.params.id; 

    console.log(("rooooomiddddddddd#########33",roomId));

    try {
        userHelper.dobooking(req.body).then((result) => {
            console.log(result);
            // Render the payment page with the correct room ID
            res.redirect("/payment/" + roomId);
        });
    } catch (error) {
        console.log(error);
    }
},


  checkavailabilty: async (req, res) => {

    const roomId = req.params.id;

    console.log("rooooooooooooomidddddddddddd",roomId);
    const { checkin, checkout } = req.body;

    try {
        const bookingData = await userHelper.dochecking(checkin, checkout);

        if (!bookingData) {
            // Dates are available and not booked, proceed with booking
            console.log("Dates are available for booking");
            try {
                // Redirect to booking page after successful booking
                res.redirect("/booking/" +roomId);
            } catch (error) {
                console.log("Error in redirecting to booking page:", error);
                res.redirect("/"); // Redirect to home page with an error message
            }
        } else {
            // Dates are not available or already booked, inform the user
            console.log("Selected dates are not available or already booked");
            res.redirect("/room/" + roomId); // Redirect to room page or any other appropriate route
        }
    } catch (error) {
        console.log("Error checking availability:", error);
        res.redirect("/"); // Redirect to home page with an error message
    }
},


paymentpage:(req,res)=>{
  let id = req.params.id;
  try {
       userHelper.roomsDetails(id).then((roomDetails)=>{
        console.log("rooooomdetailsssss&&&&&&&&&&&&&",roomDetails);
        res.render("user/payment", { roomDetails });
       });
  } catch (error) {
      console.error(error);
      res.status(500).send("Error fetching room details");
  }

},
 

payment: async (req, res) => {
  try {
      const { name, price } = req.body;

      const paymentResult = await userHelper.payment(name, price);

      // Send response back to client
      res.status(200).send(paymentResult);
  } catch (error) {
      console.log(error.message);
      // Handle error
      res.status(500).send({ success: false, msg: 'Something went wrong!' });
  }
}




}



---------------------------------------



var { connectToMongoDB } = require("../config/connection");
var collection = require("../config/collection");
const bcrypt = require("bcrypt");
const { ObjectId } = require("mongodb");
const jwt = require("jsonwebtoken");
const Razorpay = require("razorpay");


const razorpayInstance = new Razorpay({
  key_id: "rzp_test_8cTRaG2qyqmSGG",
  key_secret: "lPhtD4Guxq3dUurYJLs9OwXi"
});


module.exports = {


  doSignup: (userData) => {
    return new Promise(async (resolve, reject) => {
      //   console.log(userData);

      if (userData.password === userData.confirmpassword) {
        var encryptedpassword = await bcrypt.hash(userData.password, 10);
        // console.log(encryptedpassword);
      } else {
        console.log("error");
        throw new Error("given passwords are not same");
      }

      let signupData = {


        userId:Date.now().toString(16),


        name: userData.name,
        email: userData.email,
        password: encryptedpassword,
        blocked: false,
      };

      const db = await connectToMongoDB();

      await db
        .collection(collection.USER_COLLECTION)
        .insertOne(signupData)
        .then((data) => {
          resolve(data.insertedId);
        });
    });
  },


  doLogin: (loginData) => {
    return new Promise(async (resolve, reject) => {
      let loginstatus = false;
      let response = {};
      const db = await connectToMongoDB();
      let user = await db
        .collection(collection.USER_COLLECTION)
        .findOne({ email: loginData.email });

      if (user) {
        bcrypt.compare(loginData.password, user.password).then((status) => {
          if (status) {
            console.log("login success");
            const usertoken = jwt.sign(
              { userId: user._id, useremail: user.email },
              "secret",
              { expiresIn: "24h" }
            );
            response.token = usertoken;
            response.user = user;
            response.status = true;
            response.message = "Login Success";
            resolve(response);
          } else {
            response.message = "the user cant login";
            resolve({ status: false });
          }
        });
      } else {
        resolve({ status: false });
      }
    });
  },


  showhotels: async () => {
    return new Promise(async (resolve, reject) => {
      const db = await connectToMongoDB();

      let Datahotel = await db
        .collection(collection.HOTEL_COLLECTION)
        .find({ blocked: false })
        .toArray();
      resolve(Datahotel);
    });
  },


  showrooms: async (hotelId) => {
    try {
        const db = await connectToMongoDB();
        const hotelrooms = await db
            .collection(collection.ROOMS_COLLECTION)
            .find({ hotelId: hotelId })
            .toArray();
        return hotelrooms;
    } catch (error) {
        console.error("Error fetching hotel rooms:", error);
        throw error; // Propagate the error to the caller
    }
},


  roomsDetails: async (idroom) => {
    try {
      const db = await connectToMongoDB();
      const roomDetails = await db
        .collection(collection.ROOMS_COLLECTION)
        // .findOne({ _id: new ObjectId(roomid) });
        .find({roomId : idroom})
        .toArray();
      return roomDetails;
    } catch (error) {
      throw error;
    }
  },


  dobooking: (bookingdata) => {
    // Function to generate array of dates between checkin and checkout
    function generateDateArray(checkin, checkout) {
        let datesArray = [];
        let currentDate = new Date(checkin);
        const endDate = new Date(checkout);
        
        // Loop through each day between checkin and checkout
        while (currentDate <= endDate) {
            datesArray.push(new Date(currentDate));
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return datesArray;
    }

    return new Promise(async (resolve, reject) => {
        let datasbooking = {
            name: bookingdata.name,
            email: bookingdata.email,
            checkin: bookingdata.checkin,
            checkout: bookingdata.checkout,
            booked: false,
        };

        const db = await connectToMongoDB();

        // Generate array of dates between checkin and checkout
        let datesArray = generateDateArray(bookingdata.checkin, bookingdata.checkout);

        // Add the array of dates to datasbooking object
        datasbooking.datesArray = datesArray;

        await db
            .collection(collection.BOOKING_COLLECTION)
            .insertOne(datasbooking)
            .then((data) => {
                resolve(data.insertedId);
            })
            .catch((error) => {
                reject(error);
            });
    });
},


//   dochecking: (checkingdata) => {

//     return new Promise(async (resolve, reject) => {
//         try {
//             const db = await connectToMongoDB();
//             const checkin = new Date(checkingdata.checkin);
//             const checkout = new Date(checkingdata.checkout);

//             // Ensure check-in date is before or equal to check-out date
//             if (checkin > checkout) {
//                 reject(new Error("Check-in date cannot be later than check-out date"));
//                 return;
//             }

//             // Generate an array of dates between check-in and check-out dates
//             const datesInRange = [];
//             for (let date = checkin; date <= checkout; date.setDate(date.getDate() + 1)) {
//                 datesInRange.push(new Date(date));
//             }

            
//             // Insert the array of dates into a single document in the database
//             const result = await db.collection(collection.CHECKING_COLLECTION).insertOne({
//                 dates: datesInRange
//             });

//             resolve(result.insertedId);
//         } catch (error) {
//             console.error("Error inserting checking data:", error);
//             reject(error);
//         }
//     });
// },




dochecking: async (checkin, checkout) => {

  console.log("3#######%%%%%%%%%",checkin,checkout);
  
  try {
      const db = await connectToMongoDB();
      
      // Query the booking collection to check if any booking exists for the given date range
      const existingBooking = await db.collection(collection.BOOKING_COLLECTION).findOne({
          // $or: [
          //     { $and: [{ checkin: { $lte: new Date(checkin) } }, { checkout: { $gte: new Date(checkin) } }] }, // Check-in date falls within existing booking
          //     { $and: [{ checkin: { $lte: new Date(checkout) } }, { checkout: { $gte: new Date(checkout) } }] }, // Check-out date falls within existing booking
          //     { $and: [{ checkin: { $gte: new Date(checkin) } }, { checkout: { $lte: new Date(checkout) } }] } // Existing booking falls within the given date range
          // ]
          checkin,checkout
      });

      // Return the booking data if exists, otherwise return null
      return existingBooking;
  } catch (error) {
      throw error;
  }
},


payment: async (name, price) => {
  
  try {
      // Create options object for Razorpay order
      const options = {
          amount: price * 100, // Amount should be in smallest currency unit (paisa for INR)
          currency: 'INR',
          receipt: 'razorUser@gmail.com',
          payment_capture: '1' // Automatically capture payments
      };

      // Create Razorpay order
      const order = await new Promise((resolve, reject) => {
          razorpayInstance.orders.create(options, (err, order) => {
              if (err) {
                  reject(err);
              } else {
                  resolve(order);
              }
          });
      });

      // If order creation is successful, save payment details to MongoDB
      const paymentDetails = {
          name: name,
          amount: price,
          order_id: order.id,
          status: 'success' // Initial status
      };

      // Connect to MongoDB
      const db = await connectToMongoDB();

      // Insert payment details into MongoDB payment collection
      await db.collection(collection.PAYMENT_COLLECTION).insertOne(paymentDetails);

      // Return order details
      return {
          success: true,
          msg: 'Order Created',
          order_id: order.id,
          amount: options.amount,
          key_id: "rzp_test_8cTRaG2qyqmSGG",
          product_name: name
      };
  } catch (error) {
      console.log(error.message);
      throw error;
  }
}



};
===============================================